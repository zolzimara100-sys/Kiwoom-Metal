 변경 사항

  1. Dockerfile 수정: Multi-stage build로 변경
    - Build stage: Node.js에서 npm run build로 빌드
    - Production stage: nginx로 빌드된 정적 파일 서빙
  2. nginx 설정 추가:
    - 포트 3000에서 서빙
    - SPA 라우팅 지원 (React Router)
    - API 프록시 설정 (/api → backend)
    - 정적 파일 캐싱
  3. docker-compose.yml 수정:
    - 개발 모드 볼륨 마운트 제거
    - 프로덕션 빌드 사용

  현재 실행 중인 서비스

  ✅ kiwoom-postgres: PostgreSQL 데이터베이스 (포트 5432) - healthy
  ✅ kiwoom-redis: Redis (포트 6379) - healthy
  ✅ kiwoom-app: 백엔드 애플리케이션 (포트 8081)
  ✅ kiwoom-frontend: 프론트엔드 nginx (포트 3000) - 프로덕션 빌드 배포 완료

  접속 방법

  http://localhost:3000 으로 접속하여 개선된 섹터 선택 UI를 확인하실 수 있습니다!

  - 메인 페이지: http://localhost:3000
  - 업종분석: http://localhost:3000/moving-chart (업종분석 탭 클  릭)


FrontEnd BackEnd 운영기 개발기 url:port 정보
1. 운영기 (Docker Environment)
현재 Docker Compose를 통해 실행 중인 서비스들의 정보입니다.

서비스	URL / 접속 정보	내부 포트	호스트 매핑 포트	비고
Frontend	http://localhost:3000	3000	3000	React/Vite 앱
Backend	http://localhost:8081	8080	8081	Spring Boot API 서버
Database	localhost:5432	5432	5432	PostgreSQL (접속정보: kiwoom/kiwoom123)
Redis	localhost:6379	6379	6379	Redis Cache
참고: 현재 Backend(kiwoom-app)는 호스트의 8081 포트로 연결되어 있습니다. 따라서 운영기 테스트 시 API 호출은 http://localhost:8081/api/...로 해야 합니다.


2. 개발기 (Local Development)
로컬에서 직접 코드를 수정하고 실행(npm run dev, ./gradlew bootRun)할 때 사용하는 환경입니다.

서비스	URL / 접속 정보	포트	실행 명령어
Frontend	http://localhost:3000	3000	npm run dev (프론트엔드 폴더에서)
Backend	http://localhost:8080	8080	./gradlew bootRun (루트 폴더에서)
Database	localhost:5432	5432	(Docker의 kiwoom-postgres를 공용으로 사용)
주의 1 (포트 충돌): 현재 운영기 Frontend가 3000포트를 점유 중이므로, 로컬에서 npm run dev를 실행하려면 먼저 운영기 Frontend 컨테이너를 중지해야 합니다. (또는 Vite가 자동으로 다른 포트를 잡습니다.)

주의 2 (Backend 포트): 운영기 Backend는 8081, 개발기 Backend는 8080으로 나뉘어져 있어 동시에 실행 가능합니다. 하지만 Frontend가 어떤 Backend를 바라보는지(VITE_API_BASE_URL) 확인이 필요합니다.




[개발환경]
그런데 왜 이번 frontend는 빌드하고 배포하지 않는건가. 이전에 frontend변경할때는 항상 빌드 배포 했잖아 
무슨차이인가 

⏺ 좋은 질문입니다! 차이점을 설명드리겠습니다:

  현재 상황 (개발 모드)

  npm run dev  # 포트 3000
  - Vite 개발 서버 실행 중
  - 코드 변경 시 즉시 핫 리로딩
  - 빌드 없이 바로 테스트 가능
  - 빠른 개발 사이클

  이전 방식 (프로덕션 배포)

  docker-compose up -d --build frontend
  - 프로덕션 빌드 생성 (npm run build)
  - Docker 컨테이너로 실행
  - 실제 배포 환경과 동일
  - 최적화된 정적 파일 생성

  ---
  맞습니다! 최종 배포를 위해서는 Docker 컨테이너를 다시 빌드해야 합니다.

  Docker 컨테이너로 빌드하고 배포할까요?
                                                                                                   
⏺ User answered Claude's questions:
  ⎿  · 프론트엔드를 Docker 컨테이너로 빌드하고 배포하시겠습니까? → 그런데 화면에는 정상적으로 보임 
     docker배포하지 않았는데도 반영된 이유가 뭐야

⏺ 정확히 이해하셨습니다! 이유를 설명드리겠습니다:

  왜 Docker 배포 없이도 화면에 반영되었나?

  현재 포트 3000에서는 두 가지 서버가 번갈아 실행될 수 있습니다:

  1. Vite 개발 서버 (현재 실행 중) ✅

  npm run dev  # 포트 3000
  - 코드 변경 시 즉시 반영 (핫 리로딩)
  - 빌드 없이 소스 파일 직접 서빙
  - 제가 Docker 컨테이너를 중지하고 이것을 시작했습니다

  2. Docker 컨테이너 (현재 중지됨) ❌

  docker-compose up -d --build frontend  # 포트 3000
  - 프로덕션 빌드 파일 서빙
  - 코드 변경 시 재빌드 필요

  ---
  현재 상태 확인

⏺ Bash(docker ps | grep frontend)
  ⎿  No matches found

> /usage 

⏺ Bash(lsof -i :3000 | grep LISTEN)
  ⎿  node      87473 juhyunhwang   13u  IPv4 0x2d33e6be34925dd1      0t0  TCP *:hbci (LISTEN)

⏺ 확인 결과

  Docker 컨테이너 (frontend): ❌ 중지됨
  Node.js (Vite 개발 서버):  ✅ 포트 3000에서 실행 중 (PID: 87473)

  결론

  현재 http://localhost:3000에 접속하면:
  - Vite 개발 서버의 화면을 보게 됩니다
  - 코드 변경 시 자동으로 핫 리로딩되어 즉시 반영됩니다
  - Docker 배포 없이도 작동하는 이유입니다

  ---
  개발 vs 배포 환경

  | 구분    | 개발 환경 (현재)  | 프로덕션 배포           |
  |-------|-------------|-------------------|
  | 실행 방법 | npm run dev | docker-compose up |
  | 포트    | 3000        | 3000              |
  | 핫 리로딩 | ✅ 지원        | ❌ 없음              |
  | 빌드 필요 | ❌ 없음        | ✅ 필요              |
  | 용도    | 개발/테스트      | 실제 서비스            |

  개발 중에는 현재 방식(npm run dev)이 더 편리합니다. 실제 서비스 배포 시에만 Docker를 사용하면 됩니다.
